<!DOCTYPE HTML><html><head><meta charset="utf-8"><title>延迟求值-如何让Lo-Dash再提速x100? | JSBear</title><meta name="author" content="JSBear Team"><meta name="description" content="我们是一群搞前端的熊孩子:()"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta property="og:title" content="延迟求值-如何让Lo-Dash再提速x100?"><meta property="og:site_name" content="JSBear"><meta property="og:image" content="undefined"><link href="/jsbear/favicon.png" rel="icon"><link rel="stylesheet" href="/jsbear/css/jquery.tocify.css" media="screen" type="text/css"><link rel="stylesheet" href="/jsbear/css/bootstrap.min.css" media="screen" type="text/css"><link rel="stylesheet" href="/jsbear/material/css/ripples.css" media="screen" type="text/css"><link rel="stylesheet" href="/jsbear/material/css/material.css" media="screen" type="text/css"><link rel="stylesheet" href="/jsbear/css/font-awesome.css" media="screen" type="text/css"><link rel="stylesheet" href="/jsbear/css/style.css" media="screen" type="text/css"><link rel="stylesheet" href="/jsbear/css/highlight.light.css" media="screen" type="text/css"><link rel="stylesheet" href="/jsbear/css/google-fonts.css" media="screen" type="text/css"><!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]--><script src="/jsbear/js/jquery-2.0.3.min.js"></script></head><body><nav id="main-nav" class="navbar navbar-default" role="navigation"><div class="container"><button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse"><span class="sr-only">Toggle navigation</span> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span></button> <a class="navbar-brand" href="/jsbear/">JSBear</a><div class="collapse navbar-collapse nav-menu"><ul class="nav navbar-nav navbar-right"><li><a href="/jsbear/"><i class="fa fa-home"></i>首页</a></li><li><a href="/jsbear/archives"><i class="fa fa-list"></i>存档</a></li><li><a href="/jsbear/categories"><i class="fa fa-folder"></i>分类</a></li><li><a href="/jsbear/categories/译文/"><i class="mdi-action-description"></i>译文</a></li><li><a href="/jsbear/works"><i class="mdi-action-polymer"></i>Works</a></li><li><a href="/jsbear/about"><i class="fa fa-info-circle"></i>关于</a></li><li><a href="/jsbear/atom.xml"><i class="fa fa-rss"></i>RSS</a></li></ul></div></div></nav><div class="clearfix"></div><div class="container"><div class="content"><div class="page-header"><h1>延迟求值-如何让Lo-Dash再提速x100?</h1></div><div class="row post"><div class="col-md-9"><div class="mypage"><div class="row widget-wrapper"><div class="post-meta-item"><i class="fa fa-clock-o"></i> <span class="post-time">2014-11-14 9:57:03</span></div><div class="post-meta-item"><i class="mdi-action-face-unlock" title="作者"></i> <span>wayou</span></div><div class="post-meta-item"><i class="fa fa-folder"></i> <a class="label label-success" href="/jsbear/categories/译文/">译文</a></div><div class="post-meta-item"><i class="fa fa-tags"></i> <a class="label label-warning" href="/jsbear/tags/JavaScript/">JavaScript</a> <a class="label label-warning" href="/jsbear/tags/性能优化/">性能优化</a></div></div><blockquote><p>「注释」作者在本文里没有说明这么一个事实：<br>目前的版本<code>Lo-Dash v2.4.1</code>并没有引入延迟求值的特性，<code>Lo-Dash 3.0.0-pre</code>中部分方法进行了引入，比如<code>filter()</code>,<code>map()</code>,<code>reverse()</code>。</p><p>原文：<a href="http://filimanjaro.com/blog/2014/introducing-lazy-evaluation" target="_blank" rel="external">How to Speed Up Lo-Dash ×100? Introducing Lazy Evaluation</a></p></blockquote><p>我时常觉得像<code>Lo-Dash</code>这样优秀的库已经无法再优化了。它整合了各种<a href="https://www.youtube.com/watch?v=NthmeLEhDDM" target="_blank" rel="external">奇技淫巧</a>已经将JavaScript的性能开发到了极限。它使用了最快速的语句，优化的算法，甚至还会在发版前做性能测试以保证回归没问题。</p><a id="more"></a><h1 id="延迟求值">延迟求值</h1><p>但似乎我错了-还可以让<code>Lo-Dash</code>有明显的提升。只需将关注点从细微的优化转移到算法上来。譬如，在一次循环中我们往往会去优化循环体：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> len = getLength();</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) {</div><div class="line">    operation(); <span class="comment">// &lt;- 10ms - 如何做到 9ms?!</span></div><div class="line">}</div></pre></td></tr></table></figure><p>但针对循环体的优化往往很难，很多时候已经到极限了。相反，优化<code>getLength()</code> 函数尽量减少循环次数变得更有意义了。你想啊，这个数值越小，需要循环的<code>10ms</code>就越少。</p><p>这便是<code>Lo-Dash</code>实现延迟求值的大致思路。重要的是减少循环次数，而不是每次循环的时间。让我们考察下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">priceLt</span><span class="params">(x)</span> </span>{</div><div class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">(item)</span> </span>{ <span class="keyword">return</span> item.price &lt; x; };</div><div class="line">}</div><div class="line"><span class="keyword">var</span> gems = [</div><div class="line">   { name: <span class="string">'Sunstone'</span>, price: <span class="number">4</span> }, { name: <span class="string">'Amethyst'</span>, price: <span class="number">15</span> },</div><div class="line">   { name: <span class="string">'Prehnite'</span>, price: <span class="number">20</span>}, { name: <span class="string">'Sugilite'</span>, price: <span class="number">7</span>  },</div><div class="line">   { name: <span class="string">'Diopside'</span>, price: <span class="number">3</span> }, { name: <span class="string">'Feldspar'</span>, price: <span class="number">13</span> },</div><div class="line">   { name: <span class="string">'Dioptase'</span>, price: <span class="number">2</span> }, { name: <span class="string">'Sapphire'</span>, price: <span class="number">20</span> }</div><div class="line">];</div><div class="line"></div><div class="line"><span class="keyword">var</span> chosen = _(gems).filter(priceLt(<span class="number">10</span>)).take(<span class="number">3</span>).value();</div></pre></td></tr></table></figure><p>我们只想取出3个价格低于10元的小球。通常情况下我们先过滤整个数据源，最后从所有小于10的元素里返回前面三个即可。</p><p><img src="/jsbear/asset/posts/2014-11-14-lazy-evaluation/lodash-naive.gif" alt="lo-dash naive"></p><p>但这种做法并不优雅。它处理了全部8个数据，但其实只需要处理前面5个我们就能拿到结果了。同样为了得到正确的结果，延迟求值则只处理最少的元素。优化后如下图所示：</p><p><img src="/jsbear/asset/posts/2014-11-14-lazy-evaluation/grafika.gif" alt="lo-dash naive"></p><p>一下子就获得了37.5%的性能提升。很容易找出提升X1000+的例子。比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> phoneNumbers = [<span class="number">5554445555</span>, <span class="number">1424445656</span>, <span class="number">5554443333</span>, … ×<span class="number">99</span>,<span class="number">999</span>];</div><div class="line"></div><div class="line"><span class="comment">// 取出100个含 `55` 的号码</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">contains55</span><span class="params">(str)</span> </span>{</div><div class="line">    <span class="keyword">return</span> str.contains(<span class="string">"55"</span>); </div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">var</span> r = _(phoneNumbers).map(<span class="built_in">String</span>).filter(contains55).take(<span class="number">100</span>);</div></pre></td></tr></table></figure><p>这个例子中<code>map</code>和<code>filter</code> 将遍历99999 个元素，但很有可能我们只需处理到1000个元素的时候就已经拿到想要的结果了。这回性能的提升就太明显了（<a href="http://jsperf.com/lazy-demo" target="_blank" rel="external">benchmark</a>）：</p><p><img src="/jsbear/asset/posts/2014-11-14-lazy-evaluation/benchmark.jpg" alt="benchmark"></p><h1 id="流水线">流水线</h1><p>延迟求值同时带来了另一个好处，我称之为“流水线”。要旨就是避免产生中间数组，而是对一个元素一次性进行完所有操作。下面用代码说话：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> result = _(source).map(func1).map(func2).map(func3).value();</div></pre></td></tr></table></figure><p>上面看似优雅的写法在原始的<code>Lo-Dash</code>里会转换成下面的样子（直接求值）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> result = [], temp1 = [], temp2 = [], temp3 = [];</div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; source.length; i++) {</div><div class="line">   temp1[i] = func1(source[i]);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; source.length; i++) {</div><div class="line">   temp2[i] = func2(temp1[i]);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; source.length; i++) {</div><div class="line">   temp3[i] = func3(temp2[i]);</div><div class="line">}</div><div class="line">result = temp3;</div></pre></td></tr></table></figure><p>当引入了延迟求值后，代码大致就成这样的了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> result = [];</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; source.length; i++) {</div><div class="line">   result[i] = func3(func2(func1(source[i])));</div><div class="line">}</div></pre></td></tr></table></figure><p>减少不必要的中间变量多少会带来性能上的提升，特别是在数据源特别巨大，内存又吃紧的情况下。</p><h1 id="延迟执行">延迟执行</h1><p>延迟求值带来的另一个好处是延迟执行。无论何时你写了段链式代码，只有在显式地调用了<code>.value()</code>后才会真正执行。这样一来，在数据源需要异步去拉取的情况下，可以保证我们处理的是最新的数据。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> wallet = _(assets).filter(ownedBy(<span class="string">'me'</span>))</div><div class="line">                      .pluck(<span class="string">'value'</span>)</div><div class="line">                      .reduce(sum);</div><div class="line"></div><div class="line">$json.get(<span class="string">"/new/assets"</span>).success(<span class="function"><span class="keyword">function</span><span class="params">(data)</span> </span>{</div><div class="line">    assets.push.apply(assets, data); <span class="comment">// 更新数据源</span></div><div class="line">    wallet.value(); <span class="comment">// 返回的结果是最新的</span></div><div class="line">});</div></pre></td></tr></table></figure><p>而且这种机制在某些情况下也会提高执行效果。我们可以老早发送一个请求获取数据，然后指定一个精确的时间来执行。</p><h1 id="后记">后记</h1><p>延迟求值并且不算什么新技术。在一些库中已经在使用了，比如<a href="http://en.wikipedia.org/wiki/Language_Integrated_Query" target="_blank" rel="external">LINQ</a>,<a href="http://danieltao.com/lazy.js/" target="_blank" rel="external">Lazy.js</a>还有其他等等。那么问题来了，<code>Lo-Dash</code>存在的意义是啥？我想就是你仍然可以使用你熟悉的<code>Underscore</code> 接口但享受一个更高效的底层实现，不需要额外的学习成本，代码上面也不会有大的变动，只需稍加修改。</p><blockquote><p>译注：对于<code>lazy evaluation</code> 与<code>deferred execution</code> 中<code>lazy</code> 与<code>deferred</code> 的区分，在翻译时找不到恰当的区分。前者用主流使用的「延迟」会更易懂，而后者同时也译为「延迟」, 但他们在记性上还是存在一定差别的，具体的讨论可见<a href="https://github.com/tbfe/translation/pull/2#discussion_r20362267" target="_blank" rel="external">这里</a>。</p></blockquote></div><div><center><div class="pagination-wrapper"><a class="btn btn-default disabled"><i class="fa fa-chevron-left"></i>上一篇</a> <a class="btn btn-default" href="/jsbear/"><i class="fa fa-home"></i>首页</a> <a class="btn btn-default" href="/jsbear/2014/10/22/hello-world/" class="alignright next">下一篇<i class="fa fa-chevron-right"></i></a></div></center></div><section id="comment"><div class="ds-thread" data-thread-key="_posts/2014-11-14-lazy-evaluation.md" data-title="延迟求值-如何让Lo-Dash再提速x100?" data-url="http://jsbear.baidu.com/2014/11/14/lazy-evaluation/"></div><script type="text/javascript">var duoshuoQuery={short_name:"jsbear"};!function(){var t=document.createElement("script");t.type="text/javascript",t.async=!0,t.src=("https:"==document.location.protocol?"https:":"http:")+"//static.duoshuo.com/embed.js",t.charset="UTF-8",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(t)}();</script></section></div><div class="col-md-3"><div id="toc"></div></div></div></div></div><div class="container-narrow"><footer><p>我们是来自贴吧搞前端的一群熊孩子:()</p><p>&copy; 2014 <a href="http://jsbear.baidu.com">JSBear Team</a></p></footer></div><a id="gotop" href="#"><i class="fa fa-chevron-circle-up"></i></a><script src="/jsbear/js/jquery.imagesloaded.min.js"></script><script src="/jsbear/js/gallery.js"></script><script src="/jsbear/js/bootstrap.min.js"></script><script src="/jsbear/material/js/ripples.js"></script><script src="/jsbear/material/js/material.js"></script><script src="/jsbear/js/jqueryui.js"></script><script src="/jsbear/js/jquery.tocify.js"></script><script src="/jsbear/js/main.js"></script></body></html>